---
title: Java 8 的 Lambda 表达式
date: 2019-03-18 23:45:52
updated: 2019-03-20 00:52:52
categories:
    - Java
tags:
    - java
    - lambda
---
---

# 简介

Java 8 的 Lambda 表达式提供了强大的函数化的编程能力，将函数作为参数传递进方法中。免去了使用匿名方法的麻烦，这样使可读性更好，表达更清晰。它是推动 Java 8 发布的最重要新特性。Lambda 表达式的简洁让人非常激动，但是如果第一次看到一段复杂的Lambda表达式的代码，会让你非常头疼，对于初学者来说，可能就是一段垃圾代码，因为你并不知道 Lambda 表达式到底在表达什么╮(╯▽╰)╭下面我们就举一些小例子由浅入深的了解下 Lambda 表达式。

<!-- more -->

# 基本语法

`(parameters) -> expression` 或者 `(parameters) ->{ statements; }`

个人理解，把 Lambda 表达式看成咱们上学的时候学的函数 `f(x) = x + 1` 会让你更容易理解。

以下是lambda表达式的重要特征:

* <b>可选类型声明：</b>不需要声明参数类型，编译器可以统一识别参数值。
* <b>可选的参数圆括号：</b>一个参数无需定义圆括号，但多个参数需要定义圆括号。
* <b>可选的大括号：</b>如果主体包含了一个语句，就不需要使用大括号。
* <b>可选的返回关键字：</b>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。

# 简单实例

``` java
public interface Operation {

    int calc(int a, int b);
}
```

``` java
public interface Greeting {

    void say(String msg);
}

```

``` java
public class LambdaTest {

    public static int calc(int a, int b, Operation operation) {
        return operation.calc(a, b);
    }

    public static void say(String msg, Greeting greeting) {
        greeting.say(msg);
    }

    public static void main(String args[]) {
        // 类型声明
        Operation addition = (int a, int b) -> a + b;

        // 不用类型声明
        Operation subtraction = (a, b) -> a - b;

        // 大括号中的返回语句。
        // 一般只有存在多行语句的时候才会使用，单行语句不需要使用，部分IDE会提示去掉大括号。
        Operation multiplication = (int a, int b) -> {
            return a * b;
        };

        // 没有大括号及返回语句
        Operation division = (int a, int b) -> a / b;

        System.out.println("10 + 5 = " + LambdaTest.calc(10, 5, addition));
        System.out.println("10 - 5 = " + LambdaTest.calc(10, 5, subtraction));
        System.out.println("10 x 5 = " + LambdaTest.calc(10, 5, multiplication));
        System.out.println("10 / 5 = " + LambdaTest.calc(10, 5, division));

        // 不用括号
        Greeting sayHello = message -> System.out.println("Hello " + message);

        // 用括号
        Greeting sayBye = (message) -> System.out.println("Bye " + message);

        LambdaTest.say("cylong", sayHello);
        LambdaTest.say("cylong", sayBye);
        LambdaTest.say("cylong", message -> System.out.println("Hi " + message));
        
        // 以前的匿名方法
        LambdaTest.say("cylong", new Greeting() {
            @Override
            public void say(String msg) {
                System.out.println("Hello " + msg);
            }
        });
    }
}
```

以上代码的输出为：

```
10 + 5 = 15
10 - 5 = 5
10 x 5 = 50
10 / 5 = 2
Hello cylong
Bye cylong
Hello cylong
Hello cylong
```

# Java 8 的 Stream API

其实目前用 Lambda 表达式最多的地方就是 Java 8 的新特性——Stream API，借助于 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的。在以前的 Java API中，我们更多的是使用for或者Iterator来遍历集合，同时我们可能会对集合里的数据进行过滤，计算等等处理，导致代码量非常的多，还容易出错。而使用 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。下面我们就看一些例子，深入了解下 Stream 的使用。

## 集合迭代

``` java
    List<Integer> numList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    
    // 普通的 for 循环
    for (int n : numList) {
        System.out.println(n);
    }
    
    // 使用 Lambda 表达式
    numList.forEach(n -> System.out.println(n));
    
    // 使用 Java 8 的方法引用
    // 看起来像C++的作用域解析运算符
    numList.forEach(System.out::println);
```
上面的例子包含普通的for循环，Lambda表达式遍历的方式，最后一种方式是方法引用，让代码量再次减少，代码更加清晰。

## 集合过滤

``` java
    // 输出集合中所有大于5的值
    numList.stream().filter(n -> n > 5).forEach(System.out::println);
```

上面的代码中 `filter(n -> n > 5)`就是获得集合中大于5的所有值，filter 的参数是 `java.util.function.Predicate`，返回值是一个 Stream。使用 Predicate 可以向API方法添加逻辑，用更少的代码支持更多的动态行为。上面的例子就是使用 Predicate 对集合进行过滤。在 filter() 方法中，我们可以写更多复杂的逻辑来过滤集合元素。甚至可以使用 `and()` 或者 `or()`等合并多个条件，如下面这样。

``` java
    // 输出集合中所有大于5并且小于8的值
    Predicate<Integer> start = n -> n >5;
    Predicate<Integer> end = n -> n <8;
    numList.stream().filter(start.and(end)).forEach(System.out::println);
```

另外，关于 filter() 方法有个常见误解。在现实生活中，做过滤的时候，通常会丢弃部分，但使用filter()方法则是获得一个新的列表，且其每个元素符合过滤原则。

``` java
    // 创建一个新的集合，所有元素的值大于5
    List<Integer> newNumList = numList.stream().filter(n -> n > 5).collect(Collectors.toList());
    newNumList.forEach(System.out::println);
    System.out.println();
    numList.forEach(System.out::print);
```

输出是：

```
678910
12345678910
```

## Stream 的 map 示例

``` java
    // 将集合中的所有值计算平方后输出
    numList.stream().map(n -> n * n).forEach(System.out::println);
```

本例介绍最广为人知的函数式编程概念 map。它允许你将对象进行转换。例如在本例中，我们将 `n -> n * n` lambda 表达式传到 map() 方法，后者将其应用到流中的每一个元素。然后用 `forEach()` 将列表元素打印出来。

## Stream 的 Reduce 示例

``` java
    // 将集合中的所有值求和
    int result = numList.stream().reduce((sum, n) -> sum + n).get();
    System.out.println(result);
```

在上个例子中，可以看到map将集合类（例如列表）元素进行转换的。还有一个 reduce() 函数可以将所有值合并成一个。Map和Reduce操作是函数式编程的核心操作，因为其功能，reduce 又被称为折叠操作。另外，reduce 并不是一个新的操作，你有可能已经在使用它。SQL中类似 sum()、avg() 或者 count() 的聚集函数，实际上就是 reduce 操作，因为它们接收多个值并返回一个值。流API定义的 reduce() 函数可以接受lambda表达式，并对所有值进行合并。IntStream这样的类有类似 average()、count()、sum() 的内建方法来做 reduce 操作，也有mapToLong()、mapToDouble() 方法来做转换。这并不会限制你，你可以用内建方法，也可以自己定义。

## 计算集合元素的最大值、最小值、总和以及平均值

``` java
    // 计算集合元素的最大值、最小值、总和以及平均值
    IntSummaryStatistics stats = numList.stream().mapToInt((x) -> x).summaryStatistics();
    System.out.println("Highest prime number in List : " + stats.getMax());
    System.out.println("Lowest prime number in List : " + stats.getMin());
    System.out.println("Sum of all prime numbers : " + stats.getSum());
    System.out.println("Average of all prime numbers : " + stats.getAverage());
```

输出：
```
Highest prime number in List : 10
Lowest prime number in List : 1
Sum of all prime numbers : 55
Average of all prime numbers : 5.5
```

# 参考资料
> [Java 8 Lambda 表达式 | 菜鸟教程][1]
> [Java 8 中的 Streams API 详解 | IBM Developer][2]
> [Java 8 Lambda 表达式10个示例 | ImportNew][3]
> [Java 8 parallelStream 浅析][4]

---

> 文章标题：<a href='{{ permalink }}' title='{{ title }}' >{{ title }}</a>
> 文章作者：[cylong](http://www.cylong.com/about/ "cylong")
> 文章链接：<a href='{{ permalink }}' title='{{ title }}' >{{ permalink }}</a>
> 有问题或者建议欢迎在下方评论。欢迎转载、引用，但希望标明出处，感激不尽(●'◡'●)

[1]: http://www.runoob.com/java/java8-lambda-expressions.html "Java 8 Lambda 表达式 | 菜鸟教程"
[2]: https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html "Java 8 中的 Streams API 详解 | IBM Developer"
[3]: http://www.importnew.com/16436.html "Java 8 Lambda 表达式10个示例 | ImportNew"
[4]: https://zhuanlan.zhihu.com/p/43039062 "Java 8 parallelStream 浅析"

